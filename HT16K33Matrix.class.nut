class HT16K33Matrix
{
	// Squirrel class for 1.2-inch 8x8 LED matrix displays driven by the HT16K33 controller
	// For example: http://www.adafruit.com/products/1854
	// Communicates with any imp I2C bus
 
	// Availibility: Device

	// Written by Tony Smith (@smittytone) October 2014
	// Version 1.0
	// Copyright 2014 Electric Imp
	// Issued under the MIT license (MIT)

	// HT16K33 registers and HT16K33-specific variables

	static HT16K33_REGISTER_DISPLAY_ON  = "\x81"
	static HT16K33_REGISTER_DISPLAY_OFF = "\x80"
	static HT16K33_REGISTER_SYSTEM_ON   = "\x21"
	static HT16K33_REGISTER_SYSTEM_OFF  = "\x20"
	static HT16K33_DISPLAY_ADDRESS	  = "\x00"
	static HT16K33_I2C_ADDRESS		  = 0x70

	static charset = [
	[0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0],          // Space - Ascii 32
	[0x0,0x10,0x10,0x10,0x10,0x0,0x10,0x0],     // !
	[0x0,0x24,0x24,0x0,0x0,0x0,0x0,0x0],        // ”
	[0x0,0x24,0x7E,0x24,0x24,0x7E,0x24,0x0],    // #
	[0x0,0x8,0x3E,0x28,0x3E,0xA,0x3E,0x8],      // $
	[0x0,0x62,0x64,0x8,0x10,0x26,0x46,0x0],     // %
	[0x0,0x10,0x28,0x10,0x2A,0x44,0x3A,0x0],    // &
	[0x0,0x8,0x10,0x0,0x0,0x0,0x0,0x0],         // ‘
	[0x0,0x4,0x8,0x8,0x8,0x8,0x4,0x0],          // (
	[0x0,0x20,0x10,0x10,0x10,0x10,0x20,0x0],    // )
	[0x0,0x0,0x14,0x8,0x3E,0x8,0x14,0x0],       // *
	[0x0,0x0,0x8,0x8,0x3E,0x8,0x8,0x0],         // +
	[0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x10],         // ,
	[0x0,0x0,0x0,0x0,0x3E,0x0,0x0,0x0],         // -
	[0x0,0x0,0x0,0x0,0x0,0x18,0x18,0x0],        // .
	[0x0,0x2,0x4,0x8,0x10,0x20,0x40,0x0],       // /
	[0x0,0x3C,0x46,0x4A,0x52,0x62,0x3C,0x0],    // 0 - Ascii 48
	[0x0,0x30,0x50,0x10,0x10,0x10,0x7C,0x0],    // 1
	[0x0,0x3C,0x42,0x2,0x3C,0x40,0x7E,0x0],     // 2
	[0x0,0x3C,0x42,0xC,0x2,0x42,0x3C,0x0],      // 3
	[0x0,0x8,0x18,0x28,0x48,0x7E,0x8,0x0],      // 4
	[0x0,0x7E,0x40,0x7C,0x2,0x42,0x3C,0x0],     // 5
	[0x0,0x3C,0x40,0x7C,0x42,0x42,0x3C,0x0],    // 6
	[0x0,0x7E,0x2,0x4,0x8,0x10,0x10,0x0],       // 7
	[0x0,0x3C,0x42,0x3C,0x42,0x42,0x3C,0x0],    // 8
	[0x0,0x3C,0x42,0x42,0x3E,0x2,0x3C,0x0],     // 9
	[0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0],        // : - Ascii 58
	[0x0,0x0,0x10,0x0,0x0,0x10,0x10,0x20],      //
	[0x0,0x0,0x4,0x8,0x10,0x8,0x4,0x0],         // <
	[0x0,0x0,0x0,0x3E,0x0,0x3E,0x0,0x0],        // =
	[0x0,0x0,0x10,0x8,0x4,0x8,0x10,0x0],        // >
	[0x0,0x3C,0x42,0x4,0x8,0x0,0x8,0x0],        // ?
	[0x0,0x3C,0x4A,0x56,0x5E,0x40,0x3C,0x0],    // @
	[0x0,0x3C,0x42,0x42,0x7E,0x42,0x42,0x0],    // A - Ascii 65
	[0x0,0x7C,0x42,0x7C,0x42,0x42,0x7C,0x0],    // B
	[0x0,0x3C,0x42,0x40,0x40,0x42,0x3C,0x0],    // C
	[0x0,0x78,0x44,0x42,0x42,0x44,0x78,0x0],    // D
	[0x0,0x7E,0x40,0x7C,0x40,0x40,0x7E,0x0],    // E
	[0x0,0x7E,0x40,0x7C,0x40,0x40,0x40,0x0],    // F
	[0x0,0x3C,0x42,0x40,0x4E,0x42,0x3C,0x0],    // G
	[0x0,0x42,0x42,0x7E,0x42,0x42,0x42,0x0],    // H
	[0x0,0x7C,0x10,0x10,0x10,0x10,0x7C,0x0],    // I
	[0x0,0x2,0x2,0x2,0x2,0x42,0x3C,0x0],        // J
	[0x0,0x44,0x48,0x70,0x48,0x44,0x42,0x0],    // K
	[0x0,0x40,0x40,0x40,0x40,0x40,0x7E,0x0],    // L
	[0x0,0x42,0x66,0x5A,0x42,0x42,0x42,0x0],    // M
	[0x0,0x42,0x62,0x52,0x4A,0x46,0x42,0x0],    // N
	[0x0,0x3C,0x42,0x42,0x42,0x42,0x3C,0x0],    // O
	[0x0,0x7C,0x42,0x42,0x7C,0x40,0x40,0x0],    // P
	[0x0,0x3C,0x42,0x42,0x52,0x4A,0x3C,0x0],    // Q
	[0x0,0x7C,0x42,0x42,0x7C,0x44,0x42,0x0],    // R
	[0x0,0x3C,0x40,0x3C,0x2,0x42,0x3C,0x0],     // S
	[0x0,0x7C,0x10,0x10,0x10,0x10,0x10,0x0],    // T
	[0x0,0x42,0x42,0x42,0x42,0x42,0x3C,0x0],    // U
	[0x0,0x42,0x42,0x42,0x42,0x24,0x18,0x0],    // V
	[0x0,0x42,0x42,0x42,0x42,0x5A,0x24,0x0],    // W
	[0x0,0x42,0x24,0x18,0x18,0x24,0x42,0x0],    // X
	[0x0,0x44,0x28,0x10,0x10,0x10,0x10,0x0],    // Y
	[0x0,0x7E,0x4,0x8,0x10,0x20,0x7E,0x0],      // Z - Ascii 90
	[0x0,0xE,0x8,0x8,0x8,0x8,0xE,0x0],          // [
	[0x0,0x0,0x40,0x20,0x10,0x8,0x4,0x0],       // \
	[0x0,0x70,0x10,0x10,0x10,0x10,0x70,0x0],    // ]
	[0x0,0x10,0x38,0x54,0x10,0x10,0x10,0x0],    // ^
	[0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xFF],         // _
	[0x0,0x1C,0x22,0x78,0x20,0x20,0x7E,0x0],    // £
	[0x0,0x0,0x38,0x4,0x3C,0x44,0x3C,0x0],      // a - Ascii 97
	[0x0,0x40,0x40,0x78,0x44,0x44,0x78,0x0],    // b
	[0x0,0x0,0x38,0x40,0x40,0x40,0x38,0x0],     // c
	[0x0,0x4,0x4,0x3C,0x44,0x44,0x3C,0x0],      // d
	[0x0,0x0,0x38,0x44,0x78,0x40,0x3C,0x0],     // e
	[0x0,0x30,0x40,0x60,0x40,0x40,0x40,0x0],    // f
	[0x0,0x3C,0x44,0x44,0x3C,0x4,0x38,0x0],     // g
	[0x0,0x40,0x40,0x40,0x78,0x44,0x44,0x0],    // h
	[0x0,0x20,0x0,0x60,0x20,0x20,0x70,0x0],     // i
	[0x0,0x8,0x0,0x8,0x8,0x48,0x30,0x0],        // j
	[0x0,0x40,0x50,0x60,0x60,0x50,0x48,0x0],    // k
	[0x0,0x40,0x40,0x40,0x40,0x40,0x30,0x0],    // l
	[0x0,0x0,0x68,0x54,0x54,0x54,0x54,0x0],     // m
	[0x0,0x0,0x78,0x44,0x44,0x44,0x44,0x0],     // n
	[0x0,0x0,0x38,0x44,0x44,0x44,0x38,0x0],     // o
	[0x0,0x78,0x44,0x44,0x78,0x40,0x40,0x0],    // p
	[0x0,0x3C,0x44,0x44,0x3C,0x4,0x6,0x0],      // q
	[0x0,0x0,0x1C,0x20,0x20,0x20,0x20,0x0],     // r
	[0x0,0x0,0x38,0x40,0x38,0x4,0x78,0x0],      // s
	[0x0,0x20,0x70,0x20,0x20,0x20,0x18,0x0],    // t
	[0x0,0x0,0x44,0x44,0x44,0x44,0x38,0x0],     // u
	[0x0,0x0,0x44,0x44,0x28,0x28,0x10,0x0],     // v
	[0x0,0x0,0x44,0x54,0x54,0x54,0x28,0x0],     // w
	[0x0,0x0,0x44,0x28,0x10,0x28,0x44,0x0],     // x
	[0x0,0x0,0x44,0x44,0x3C,0x4,0x38,0x0],      // y
	[0x0,0x0,0x7C,0x8,0x10,0x20,0x7C,0x0],      // z - Ascii 122
	[0x0,0xE,0x8,0x30,0x8,0x8,0xE,0x0],         // {
	[0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x0],          // |
	[0x0,0x70,0x10,0xC,0x10,0x10,0x70,0x0],     // }
	[0x0,0x14,0x28,0x0,0x0,0x0,0x0,0x0],        // ~
	[0x3C,0x42,0x99,0xA1,0xA1,0x99,0x42,0x3C]   // © - Ascii 127
	]

	// Class private properties

	_buffer = null
	_led = null
	_ledAddress = 0
	_alphaCount = 96
	_rotationAngle = 0
	_rotateFlag = false
	_inverseVideoFlag = false
	
	constructor(impI2Cbus, i2cAddress = 0x70)
	{
		// Parameters:
		// 1. Whichever configured imp I2C bus is to be used for the HT16K33
		// 2. The HT16K33's I2C address (default: 0x70)

		if (impI2Cbus == null) return null
	
		_led = impI2Cbus
		_ledAddress = i2cAddress << 1

		// Buffer stores the character matrix values for each row of the display

		_buffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
	}

	function init(brightness = 15, angle = 0)
	{
		if (angle < 0) angle = 0
		if (angle > 3) angle = 3

		_rotationAngle = angle

		if (angle != 0) _rotateFlag = true

		// Set the brightness (which of necessity wipes and power cyles the dispay)

		setBrightness(brightness)
	}

	function setBrightness(brightness = 15)
	{
		// Called when the app changes the brightness
		// Default: 15

		if (brightness > 15) brightness = 15
		if (brightness < 0) brightness = 0

		brightness = brightness + 224

		// Wipe the display completely first, so preserve what's in _buffer

		local sbuffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

		for (local i = 0 ; i < 8 ; i++)
		{
			sbuffer[i] = _buffer[i]
		}

		// Clear the LED matrix

		clearDisplay()

		// Power cycle the LED matrix

		powerDown()
		powerUp()

		// Write the new brightness value to the HT16K33

		_led.write(_ledAddress, brightness.tochar() + "\x00")

		// Restore what's was in the _buffer...

		for (local i = 0 ; i < 8 ; i++)
		{
			_buffer[i] = sbuffer[i]
		}

		// ... and write it back to the LED matrix

		_writeDisplay()
	}

	function powerDown()
	{
		_led.write(_ledAddress, HT16K33_REGISTER_DISPLAY_OFF)
		_led.write(_ledAddress, HT16K33_REGISTER_SYSTEM_OFF)
	}

	function powerUp()
	{
		_led.write(_ledAddress, HT16K33_REGISTER_SYSTEM_ON)
		_led.write(_ledAddress, HT16K33_REGISTER_DISPLAY_ON)
	}
	
	function setInverseVideo(state = true)
	{
		if (typeof state != "bool") state = true

		_inverseVideoFlag = state

		// Switch the display

		_writeDisplay()
	}
	
	function clearDisplay()
	{
		// Clears the _buffer, which is then written to the LED matrix
		
		_buffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
		_writeDisplay()
	}

	function displayIcon(glyphMatrix)
	{
		// Parameter: Array of 8 8-bit values defining a pixel image

		if (glyphMatrix == null || typeof glyphMatrix != "array" || glyphMatrix.len() == 0) return

		if (_rotateFlag) glyphMatrix = _rotateMatrix(glyphMatrix, _rotationAngle)

		for (local i = 0 ; i < 8 ; i++)
		{
			if (_inverseVideoFlag)
			{
				_buffer[i] = ~glyphMatrix[i]
			}
			else
			{
				_buffer[i] = glyphMatrix[i]
			}
		}

		_writeDisplay()
	}

	function displayChar(asciiValue = 32)
	{
		asciiValue = asciiValue - 32
		if (asciiValue < 0 || asciiValue > _alphaCount) asciiValue = 0

		local inputMatrix = clone(charset[asciiValue])
		if (_rotateFlag) inputMatrix = _rotateMatrix(inputMatrix, _rotationAngle)

		for (local i = 0 ; i < 8 ; i++)
		{
			if (_inverseVideoFlag)
			{
				_buffer[i] = ~inputMatrix[i]
			}
			else
			{
				_buffer[i] = inputMatrix[i]
			}
		}

		_writeDisplay()
	}

	function displayLine(line)
	{
		// Bit-scroll through the characters in the variable ‘line’

		if (line.len() == 0 || typeof line != "string" || line == null) return

		local a = 0
		local b = 0
		local count = 0
		local outputMatrix = [0,0,0,0,0,0,0,0]
		local matrixOne = [0,0,0,0,0,0,0,0]
		local matrixTwo = [0,0,0,0,0,0,0,0]

		count = line.len()
		if (count == 1)
		{
			count = 2
			line = " " + line
		}

		for (local k = 0 ; k < (count - 1) ; k++)
		{
			// Run through the line character by character up to the penultimate character

			// Get the current character to be displayed and the next character along by
			// copying them from the character set array

			a = line[k]
			b = line[k + 1]

			matrixOne = clone(charset[a - 32])
			matrixTwo = clone(charset[b - 32])

			for (local j = 0 ; j < 8 ; j++)
			{
				// We use two character matrices, one on the left and one on the right.
				// Line by line, we shift the left matrix's bit pattern one bit at a time.
				// If the seventh bit of a line in the right-hand matrix is set,
				// we then set bit 0 of the left-hand matrix.
				// We then shift the right-hand matrix leftward one bit.

				outputMatrix = matrixOne

				if (_rotateFlag) outputMatrix = _rotateMatrix(outputMatrix, _rotationAngle)

				for (local i = 0 ; i < 8 ; i++)
				{
					// Write the current character’s matrix

					if (_inverseVideoFlag)
					{
						_buffer[i] = ~outputMatrix[i]
					}
					else
					{
						_buffer[i] = outputMatrix[i]
					}

					// Use the Logical Shift Left operator to move the line one pixel

					matrixOne[i] = matrixOne[i] << 1

					// Move over second matrix by one pixel

					if ((matrixTwo[i] & 128) > 0)
					{
						// If bit 7 of the right-hand character’s line is set,
						// carry it over to bit 0 of the left-hand character

						matrixOne[i] = matrixOne[i] | (1 << 0)
					}

					// Shift right-hand character line left one pixel

					matrixTwo[i] = (matrixTwo[i] << 1)
				}

				imp.sleep(0.04)
				_writeDisplay()
			}
		}

		// For the final character, we need to perform a last pixel shift to leave
		// the character completely on the display

		outputMatrix = matrixOne
		if (_rotateFlag) outputMatrix = _rotateMatrix(outputMatrix, _rotationAngle)

		for (local i = 0 ; i < 8 ; i++)
		{
			if (_inverseVideoFlag)
			{
				_buffer[i] = ~outputMatrix[i]
			}
			else
			{
				_buffer[i] = outputMatrix[i]
			}

			matrixOne[i] = matrixOne[i] << 1

			if ((matrixTwo[i] & 128) > 0) matrixOne[i] = matrixOne[i] | (1 << 0)
			matrixTwo[i] = (matrixTwo[i] << 1)
		}

		imp.sleep(0.04)
		_writeDisplay()
	}

	// PRIVATE functions DO NOT CALL

	function _writeDisplay()
	{
		// Takes the contents of _buffer and writes it to the LED matrix
		// Uses function processByte() to manipulate regular values to 
		// Adafruit 8x8 matrix's format

		local dataString = HT16K33_DISPLAY_ADDRESS

		for (local i = 0 ; i < 8 ; i++)
		{
			dataString = dataString + (_processByte(_buffer[i])).tochar() + "\x00"
		}

		_led.write(_ledAddress, dataString)
	}

	function _rotateMatrix(inputMatrix, angle = 0)
	{
		// Value of angle determines the rotation:
		// 0 = none, 1 = 90 clockwise, 2 = 180, 3 = 90 anti-clockwise

		if (angle < 1 || angle > 3) return inputMatrix

		// Rotate the character matrix through 90 degrees

		local a = 0
		local lineValue = 0
		local outputMatrix = [0,0,0,0,0,0,0,0]

		for (local i = 0 ; i < angle ; i++)
		{
			outputMatrix = [0,0,0,0,0,0,0,0]

			for (local j = 0 ; j < 8 ; j++)
			{
				lineValue = inputMatrix[j]

				for (local k = 7 ; k > -1 ; k--)
				{
					a = (lineValue & math.pow(2, k).tointeger())
					if (a > 0) outputMatrix[7 - k] = outputMatrix[7 - k] + math.pow(2, j).tointeger()
				}
			}
			
			inputMatrix = outputMatrix
		}

		return outputMatrix
	}
	
	function _processByte(byteValue)
	{
		// Adafruit 8x8 matrix requires some data manipulation:
		// Bits 7-0 of each line need to be sent 0 through 7, 
		// and bit 0 rotate to bit 7
		
		local result = 0
		local a = 0
		
		for (local i = 0 ; i < 8 ; i++)
		{
			// Run through each bit in byteValue and set the 
			// opposite bit in result accordingly, ie. bit 0 -> bit 7,
			// bit 1 -> bit 6, etc.
			
			a = byteValue & math.pow(2, i).tointeger()
			if (a > 0) result = result + math.pow(2, 7 - i).tointeger()
		}
		
		// Get bit 0 of result
		
		result & math.pow(2, 0).tointeger()
		
		// Shift result bits one bit to right
		
		result = result >> 1
		
		// if old bit 0 is set, set new bit 7
		
		if (a > 0) result = result + 0x80
		
		return result
	}
}
